<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[虚拟机-JVM]]></title>
    <url>%2F2017%2F08%2F17%2F%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%2F</url>
    <content type="text"><![CDATA[运行时数据区域JVM将内存分成几个区域分别存储不同类别的数据,有的区域随JVM启动而存在,并且在全局中共享,比如堆,方法区。而有的区域则是在创建线程时生成,跟线程一一对应,比如VM栈,Native栈,程序计数器. 堆:所有对象和数组都在堆上分配 方法区: 运行时常量区:这部分主要存放字符串常量,符号引用,直接引用.(编译器不知道引用的实际地址,用符号代替,等到运行时解析成实际地址,即直接引用) 类信息,静态变量,常量,JIT编译后的代码等 VM栈,Native栈:VM栈,Native栈都是线程私有的,进入每个方法都会创建一个栈帧,栈帧存储的是方法内局部变量,操作数栈,返回值等 程序计数器:也是线程私有,相当于代码运行位置的指针. 虚拟机创建对象对象的创建首先得分配未使用内存给对象使用,这涉及两个问题: 如何区分未使用的内存: 算法一: 在堆中设置标志点,标志点左右分别为未使用内存,已使用的内存,但这种要求保证已经使用的内存是连续的,当发生GC时候需要对内存进行整理才能保持已经使用的内存是连续的. 算法二: 通过一个空闲列表来代表未使用的内存空间,其余的未已经使用的内存空间,当发生GC时候,只需要将释放的内存空间加入空闲列表,当分配内存时候只需要从空间列表移除对应分配的空间.主流CMS垃圾收集器不带内存整理功能所以使用这种. 如何并发地分配内存线程间不发生冲突: 使用CAS(Compare and Set)错误重试保持分配内存的原子操作 利用ThreadLocal技术,为每个线程预先划分各自的分配区域,当分配区域用完再用1方法给线程自己分配新区域. 查找对象位置的定位有两种不同的方法 方法一:通过直接指针一次指向,变量引用直接指向对象内存空间,这种非常简单,速度快.但是由于对象在堆中的内存位置由于GC的发生不断改变,所有变量引用都必须及时更改.(Hotspot采用) 方法二:通过句柄二次指向,变量引用先指向一个固定内存位置的指针,指针指向对象堆中的内存位置,这种当对象内存位置发生改变,只需要改变指针,并不需要改变所有的引用. 垃圾回收Java虚拟机并不是使用教科书中的引用计数,因为引用计数难以解决相互引用的情况,而是使用可达性分析算法,从’GC root’向下递归搜索所有的引用对象,搜索到的对象标记成不可清除,然后清除所有未标记的对象.GC root常见有以下几种: SystemClassLoader加载的类静态信息 正在运行的线程的栈帧以及线程本身这个对象 用于同步锁的对象 JNI Local/Gobal reference]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Launcher的启动]]></title>
    <url>%2F2017%2F07%2F25%2FActivity%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 本文选用API25分析 关键词 简写 ActivityManagerService AMS ActivityStackSupervisor ASS PackageManagerService PMS &lt;== 表示将进入方法内分析 DirectBoot之FallbackHomeDirectBootAPI24开始就加了DirectBoot的特性，开机到解锁前的时间，系统会进入DirectBoot模式。不过正常情况下没有开启，需要在开发选项或者使用adb开启。开启了DirectBoot之后有如下变化： 存储变化：系统会为应用提供两个不同的存储空间，一个是凭证加密空间，需要解锁后才能使用，另外一个是设备加密空间，不需要解锁，在启动后就能直接使用。 应用启动限制：只有标记了android:directBootAware=”true” 的组件才能在DirectBoot模式下启动，其他组件都无法启动。 FallbackHome由于系统应用Launcher本身并不支持DirectBoot，但是Android N前Launcher是在system_process启动时刻就立刻启动，这不符合上面提到的DirectBoot应用启动限制，所以，所以就在AndroidN及以上的系统应用Setttings中添加一个简易的Launcher应用叫FallbackHome，FallbackHome支持DirectBoot，不管是否开启了DirectBoot,AMS首先会在系统启动时刻启动FallbackHome，FallbackHome会自动判断如果不是处在DirectBoot模式下，是则会自动销毁自己，AMS会重启Home栈，真正的Launcher才启动。所以AndroidN后，开机会先启动FallbackHome，再启动真正的Launcher。 关键类 关键类 用途 ActivityManagerService 主要用于管理四大组件以及adb相关的工具 ActivityRecord AMS不会直接使用Activity，而是用ActivityRecord来记录Activity TaskRecord ActivityRecord的栈 ActivityStack TaskRecord的栈，主要有HomeStack跟AppStack，HomeStack包含Launcher跟RecentApp两个TaskRecord，AppStack包含普通Activity的TaskRecord ActivityStackSupervisor 用于管理ActivityStack ActivityStarter 将Intent转化成一个ActivityRecord并且加入到对应的ActivityStack，TaskRecord FallbackHome之启动AMS.systemReady12345678//AMS初始化的最后会执行systemReady方法public void systemReady(final Runnable goingCallback) &#123; ... //启动HomeActivity即是Launcher //这个Launcher就是简易的FallbackHome,默认用户UserId=0 startHomeActivityLocked(currentUserId, "systemReady");//&lt;== ...&#125; AMS.startHomeActivityLocked12345678910111213141516171819202122232425262728293031boolean startHomeActivityLocked(int userId, String reason) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) &#123; return false; &#125; //构建启动Launcher的Intent Intent intent = getHomeIntent(); //用PMS来查找对应intent的ActivityInfo //ActivityInfo代表着Manifest.xml中Activity的信息 //返回aInfo即是FallbackHome ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; //intent从隐式改成显式，启动必然是aInfo对应的Activity intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //查找现有的Processrecord中是否有FallbackHome的进程 //很明显，系统才刚开机，没有对应的进程，所以app==null ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //利用本方法中构建的Intent，ActiityInfo来启动HomeActivity mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);//&lt;== &#125; &#125; else &#123; Slog.wtf(TAG, "No home screen found for " + intent, new Throwable()); &#125; return true;&#125; ActivityStarter.startHomeActivityLocked12345678910111213141516171819void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) &#123; //将HomeStack中Launcher的TaskRecord移到顶端显示 //由于刚开机，HomeStack中并没有任何TaskRecord存在，所以没有任何效果这句 mSupervisor.moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); //传入参数只有intent，aInfo，其他都是null，0，false startActivityLocked(null , intent, null , null , aInfo, null , null , null , null , null , 0 , 0 , 0 , null , 0 , 0 , 0 , null , false , false , null , null , null ); //&lt;== // inResumeTopActivity是为了防止ActivityStack递归调用resumeTopActivityUncheckedLocked // 由于此次startHomeActivityLocked的调用是由系统启动时AMS的systemReady调过来的，不是从ActivityStack调过来的，所以不存在递归调用的问题 // 所以，inResumeActivity==false,不走以下流程 if (mSupervisor.inResumeTopActivity) &#123; mSupervisor.scheduleResumeTopActivities(); &#125;&#125; ActivityStarter.startActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276//传入参数只有intent，aInfo，其他都是null，0，falsefinal int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; ProcessRecord callerApp = null; //传参caller==null，不走这 if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //userId与uid是两种完全不一样的概念 //uid是linux中的uid概念，但被android用在了应用沙盒机制，也就是每个应用一般都有一个不同的uid //userId则是android自己创造的，通过uid分段来区分userId，userId=uid/100000(十万) final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; //普通的打log，没意义 if (err == ActivityManager.START_SUCCESS) &#123; Slog.i(TAG, "START u" + userId + " &#123;" + intent.toShortString(true, true, true, false) + "&#125; from uid " + callingUid + " on display " + (container == null ? (mSupervisor.mFocusedStack == null ? Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId))); &#125; // 下面这段代码主要跟startActvityForResult并且Intent带FLAG_ACTIVITY_FORWARD_RESULT相关 // 有兴趣可以自己结合FLAG_ACTIVITY_FORWARD_RESULT看 ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; // 传入参数resultTo==null，所以sourceRecord，resultRecord都为null if (resultTo != null) &#123; sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, "Will send result to " + resultTo + " " + sourceRecord); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; if (requestCode &gt;= 0) &#123; ActivityOptions.abort(options); return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT; &#125; resultRecord = sourceRecord.resultTo; if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123; resultRecord = null; &#125; resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode); &#125; if (sourceRecord.launchedFromUid == callingUid) &#123; callingPackage = sourceRecord.launchedFromPackage; &#125; &#125; //前面已经将intent改成显式intent，所以getComponent()！=null if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; //从前面也知道aInfo对应了FallbackHome,aInfo！=null if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; err = ActivityManager.START_CLASS_NOT_FOUND; &#125; //前面分析了sourceRecord=null，所以不走这里 if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.task.voiceSession != null) &#123; if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123; try &#123; intent.addCategory(Intent.CATEGORY_VOICE); if (!AppGlobals.getPackageManager().activitySupportsIntent( intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, "Activity being started in current voice task does not support voice: " + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Failure checking voice capabilities", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; &#125; //传入参数voiceSession==null，所以不走这里 if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; try &#123; if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, "Activity being started in new voice task does not support: " + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Failure checking voice capabilities", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; //前面已经分析了resultRecord==null，所以resultStack==null final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; // 判断以上流程是否出错过，如果出错就发RESULT_CANCELED的Result给相应的Activity // 过程中没有出错，不走这里 if (err != START_SUCCESS) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked( -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return err; &#125; // 检查是否有启动对应Activity的权限 // 由于传入的callingUid==0，表示Root的uid（感觉用System的Uid比较合理），检查权限必然通过 boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp, resultRecord, resultStack, options); //IntentFirewall是一个Intent的防火墙，能够拦截特定的Intent //拦截列表一般在/data/system/ifw/*.xml,默认为空 //所以 abort==false abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); //mController是一个binder，IActivityController类型，一般用于monkey监视控制AMS对Activity的操作 if (mService.mController != null) &#123; try &#123; Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; catch (RemoteException e) &#123; mService.mController = null; &#125; &#125; //拦截应用，比如多用户模型下，非管理员可能不能打开短信电话 mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage); mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid, options); intent = mInterceptor.mIntent; rInfo = mInterceptor.mRInfo; aInfo = mInterceptor.mAInfo; resolvedType = mInterceptor.mResolvedType; inTask = mInterceptor.mInTask; callingPid = mInterceptor.mCallingPid; callingUid = mInterceptor.mCallingUid; options = mInterceptor.mActivityOptions; //abort==true时候给resultActivity发送RESULT_CANCELED //前面分析abort==false，不走这 if (abort) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return START_SUCCESS; &#125; //Build.PERMISSIONS_REVIEW_REQUIRED是否要检测API&lt;23的应用的动态权限，Build.PERMISSIONS_REVIEW_REQUIRED是false，所以不走这 if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; aInfo != null) &#123; if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired( aInfo.packageName, userId)) &#123; IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingUid, userId, null, null, 0, new Intent[]&#123;intent&#125;, new String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); final int flags = intent.getFlags(); Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); newIntent.setFlags(flags | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName); newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target)); if (resultRecord != null) &#123; newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true); &#125; intent = newIntent; resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); if (DEBUG_PERMISSIONS_REVIEW) &#123; Slog.i(TAG, "START u" + userId + " &#123;" + intent.toShortString(true, true, true, false) + "&#125; from uid " + callingUid + " on display " + (container == null ? (mSupervisor.mFocusedStack == null ? Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId))); &#125; &#125; &#125; //传参rInfo==false,不走这 if (rInfo != null &amp;&amp; rInfo.ephemeralResolveInfo != null) &#123; intent = buildEphemeralInstallerIntent(intent, ephemeralIntent, rInfo.ephemeralResolveInfo.getPackageName(), callingPackage, resolvedType, userId); resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); &#125; //构建ActivityRecored ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); if (outActivity != null) &#123; outActivity[0] = r; &#125; //前面分析了sourceRecord==null，不走这 if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; r.appTimeTracker = sourceRecord.appTimeTracker; &#125; //mSupervisor.mFocusedStack在AMS设置WindowManager就设置成HomeStack final ActivityStack stack = mSupervisor.mFocusedStack; //这块主要处理AppSwitch，当按下home键后，会回到home界面。 //从按下Home键之后5秒内，后台启动Activity（非用户主动）会进入队列中等待启动，5秒结束了才会启动 if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, "Activity start")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack, callerApp); mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; doPendingActivityLaunchesLocked(false); try &#123; mService.mWindowManager.deferSurfaceLayout(); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask);//&lt;== &#125; finally &#123; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack); return err;&#125;]]></content>
      <categories>
        <category>AMS剖析</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>