<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AIDL后面的世界]]></title>
    <url>%2F2017%2F09%2F26%2FAIDL%E8%83%8C%E5%90%8E%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 前言对于应用开发者并不是很好地理解Android系统服务中Proxy,Stub,Binder,IInterface,Native等一堆名词.因为AIDL自动生成了一套代码,让应用开发者不需要理解Binder的相关信息就能轻易地使用Binder进行通信.所以,我们必须知道AIDL究竟做了什么才能理解Binder的通信的Java部分. AIDL做了什么对于有一个aidl文件,比如最简单的:123interface IAidlInterface&#123; void send(String data);&#125; Android SDK会基于aidl生成一个Java文件:IAidlInterface.java这个文件主要有三部分: 最外层:IAidlInterface接口123public interface IAidlInteface etends android.os.IInterface&#123; public void send(String data) throws RemoteException;&#125; 客户端通过IAidlInterface接口调用服务端,IInterface标记着当前的接口是基于Binder通信的. IAidlInterface的静态内部抽象类:Stub用户需在服务端将实现Stub,并将Stub提交.123456789101112131415161718192021222324252627282930313233343536373839public static abstract class Stub extends android.os.Binder implements IAidlInterface&#123; private static final String DESCRIPTOR = "packagename.IAidlInterface"; static final int TRANSACTION_send = (IBinder.FIRST_CALL_TRANSACTION)+0; public Stub()&#123; attachInterace(this,DESCRIPTOR); &#125; //如果是客户端调用Stub.asInterface, 将返回Proxy //如果是服务端调用Stub.asInterface, 将直接返回Stub的实现类 public static IAidlInterface asInterace(IBinder obj)&#123; if (obj ==null)&#123; return null; &#125; IInterface iin=obj.queryLocalInterface(DESCRIPTIOR); if ((iin instanceof IAidlInterface))&#123; return (IAidlInterface)iin; &#125; return new Stub.Proxy(obj); &#125; public IBinder asBinder()&#123; return this; &#125; //当客户端调用Binder(其实就是Proxy)的transact方法,服务端就会响应调用onTransact public boolean onTransact(int code ,Parcel data,Parcel reply,int flags)&#123; switch(code)&#123; case INTERACE_TRANSACTION:&#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_send:&#123; data.enfaceInterafce(DESCRIPTIOR); String arg0=data.readString(); send(arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code,data,reply,flags); &#125;&#125; 3.Stub的私有静态内部类:Proxy客户端建立服务连接后会收到IBinder对象,通过前文说的Stub.asInerface()将其转化成一个Proxy对象,这个对象代理mRemote.客户端通过操作Proxy来调用客户端收到IBinder对象,从而调用服务端中Stub实现的方法.1234567891011121314151617181920212223242526private static class Proy implements IAidlInterface&#123; private IBinder mRemote; Proxy(IBinder remote)&#123; mRemote=remote; &#125; public IBinder asBinder&#123; return mRemote; &#125; public String getInerfaceDescriptor()&#123; return DESCRIPTIOR; &#125; //在客户端中调用接口方法相当于对Binder调用transact方法,从而调用服务端方法 public void send(String data) throws RemoteException&#123; Parcel _data=Parcel.obtain(); Parcel _reply=Parcel.obtain(); try&#123; _data,writeInterceToken(DESCRIPTIOR); _data.writeString(data); mRemote.transact(TRANSACTION_send,_data,_reply,0); _reply.readException(); &#125;finally&#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; Stub在Framework中还有另外一个名字叫Native,比如ActivityManagerNative,所以,AIDL构建了一套代码如下图: 神秘的mRemote与Stub从前面可以知道,AIDL生成了一系列类,Proxy,Stub,IAidlInterface.其中IAidlInterface和Stub由服务端实现;而Proxy由客户端实现,Proxy代理mRemote,那么mRomte这个对象从何而来,又是对应哪个IBinder的实现类?而服务端在onBind()方法中返回Stub之后又做了什么使得能跟客户端连接? 普通应用的Binder连接的建立对于普通应用而言,客户端获取到mRemote,这时候与服务端的连接就算建立了.然而客户端与服务端的连接并不是非常直接,这个过程还需要ActivityManagerService(AMS),AMS的职责之一就是管理四大控件,包括Service,所以对于bind流程来说,AMS就相当于一个中间人,帮助客户端跟服务端建立连接.这个过程涉及n多类,如ActivityManagerService,ActiveServices,ActivityThread,ApplicationThread,Service,ContextImpl,这个过程的主要思路如下:所以可以知道,其实mRemote是服务端Stub在客户端的Binder映射.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android与设计模式]]></title>
    <url>%2F2017%2F09%2F14%2FAndroid%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 面向对象的六大原则我们代码设计与维护都需要用到面向对象的六大原则 6=SOLID(5)+迪米特法则(1) 原则 解析 S单一职责原则 职责意思是引起变化的原因,一个类只有引起一个变化的原因,可是引起变化的原因比较主观,难以实践 O开闭原则 能够拓展但是不能够修改 L里氏替换 子类能完全代替父类 I接口隔离 客户不被强制实现那些不需要的接口 D依赖倒置 高层模块不直接依赖于底层模块,而是依赖于底层模块的抽象 迪米特 只跟直接朋友交流,但可能造成过多的友元类]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Android</tag>
        <tag>设计模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2017%2F09%2F08%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 Git中文件的状态 命令整理 命令 意义 git init 将本目录设置成仓库 git add 状态从untracked到暂存区,或者从modified到暂存区 git status 当前工作区中文件的状态 git log 显示log,加–pretty=oneline优化显示 git commit -m “message” 提交,从暂存区到unmodified git reset –hard/mixed/soft HEAD^ 重置,默认是mixed模式,soft模式代表重置commit(commit的后悔药),mixed模式代表重置commit跟暂存区(add跟commit的组合操作的后悔药),hard模式就相当于重置工作区,暂存区跟commit(相当于取消修改文件以及后面发生的事情) git reflog 获取历史commit的hash id,是git reset 的后悔药 git checkout - - file 最近一次add或者commit的文件替换工作区文件 git rm (- -cached)file 将文件状态从tracked改为untracked,若有cached表示不删除文件 git remote add origin git@XXXXX 添加远程库,并且定义名为origin(当从远程pull下来的仓库默认的远程库也叫origin) git push (-u) (origin) (branch:remote branch) 向远程库推送分支修改-u:在多远程仓库情况下添加,表示设置默认远程仓库是origin,以后直接用git push就可以了,而branch表示推送的分支,如果没有默认当前分支 git pull (-u) (origin) (remote branch:branch) 同push git branch 查看分支列表 git branch dev 创建dev分支 git branch -d(D) dev 删除dev分支,大写D强制可以用于没有被合并的分支 git checkout dev 切换到dev分支 git checkout -b dev 创建并且切换到dev分支 git merge dev 将dev分支合并到当前分支 modify&amp;git add&amp;git commit 解决冲突 git log - -graph log显示分支合并图 git merge - -no-ff -m “merge with no-ff” dev 将dev合并到当前分支,并且添加一个merge的commit信息 git stash 将当前工作区与暂存区临时保存下来 git stash list 查看当前临时保存下来节点 git stash apply 恢复某个临时节点 git stash drop 删除某个临时节点 git stash pop 恢复栈顶节点并且删除该节点 git remote (-v) 查看远程仓库信息,-v详细信息 git checkout -b dev origin/dev 从远程dev分支Head开始创建本地dev分支 git branch -u dev origin/dev 关联本地与远程分支 git tag v0.1 (-m “detail”) (commitid) 添加Tag git tag 列出所有tag,tag名同commit id的作用 git tag -d v0.1 删除v0.1的tag git push origin v0.1 同步远程某一tag git push origin - -tag 同步所有tag git push origin :refs/tags/v0.1 同步删除远程tag 参考网站廖雪峰的Git教程(少量错误但入门可以)]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg编译]]></title>
    <url>%2F2017%2F08%2F28%2FFFmpeg%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭FFmpeg可以分成几个层,协议(IO),容器(Format),解码(Codec)所以:AVIOContext,AVFormatContext,AVCodecContext代表这三个层的上下文,而在这些层又有以下的具体化: AVOutputFormat,AVInputFormat代表各种各样的容器输出输入文件格式:MP4，FLV，3GPOutStream,InputStream 代表音频或者视频的输出输入AVPacket解码前数据结构AVFrame解码后的数据结构健值对工具：AVDictionaryDTS:解码顺序PTS:显示顺序Duration: 两帧间间隔]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git远程仓库加密]]></title>
    <url>%2F2017%2F08%2F25%2FGit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 前记国内云盘都跪了或者有功能限制,所以决定用Github来做云盘用.国内有很多带私有仓库的Git托管平台,但加密Github远程公有仓库达到类似私有仓库的效果,相当于可以创建无限免费的私有仓库.很可耻,所以未来我Github上的加密项目会考虑不加密开源. 缺点: 不支持windows,我存的数据无关紧要,安全性没验证,所以请慎用. 创建123456789101112131415161718192021222324# 安装git-remote-gcrypt和gnupgsudo apt-get install git-remote-gcrypt gnupg# 创建一个gpg的key，需要设置用户名，邮箱，描述等，不要设置过期时间gpg --gen-key# 记录一下生成的key的ID，比如2048R/A0F0B575里面的A0F0B575，2048代表加密轮数，越多越不容易破解gpg --list-keys# 生成一个测试版本库mkdir test1 &amp;&amp; cd test1git init .echo &quot;test&quot; &gt; a.txtgit add . &amp;&amp; git ci -m &quot;update&quot;# 在你的github上面创建一个project，比如：https://github.com/halida/ttt# 配置远端加密版本库git remote add cryptremote gcrypt::git@github.com:halida/ttt.git# 最好指定用哪个key加密，这样可以共享这个key给其他人用git config remote.cryptremote.gcrypt-participants &quot;A0F0B575&quot;# push到远端git push cryptremote master# 访问远端版本库，看看文件内容，和commit里面的信息，是不是都是加密的？ 分享12345678910# 导出keygpg --export-secret-key -a &quot;share@share.com&quot; &gt; secretkey.asc# 把secretkey.asc分享给其他人，拷贝的时候记得先压缩加密一下再发送，更安全# 别人电脑里面导入gpg --import secretkey.asc# 下载代码git clone gcrypt::git@github.com:halida/ttt.git test2# 也要指定一下用什么key加密git config remote.cryptremote.gcrypt-participants &quot;A0F0B575&quot;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg编译]]></title>
    <url>%2F2017%2F08%2F23%2FFFmpeg%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭Github上很多一键编译FFmpeg的项目都过时了,只能自己编译. 下载FFmpeg:https://ffmpeg.org/download.html 去掉生成库的后缀:12345678910111213# 将 $(FFmpeg)/configure 文件中的：SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;#替换为：SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;``` 3. 编写配置与编译脚本build: #!/bin/bash export TMPDIR=/home/share/ffmpeg-3.3.3/ffmpegtempNDK=/home/share/android-ndk-r14bPLATFORM=$NDK/platforms/android-14/arch-armTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64function build_one{./configure \ –prefix=$PREFIX \ –target-os=linux \ –cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \ –arch=arm \ –sysroot=$PLATFORM \ –extra-cflags=”-I$PLATFORM/usr/include” \ –cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \ –nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \ –enable-cross-compile \ –disable-programs \ –disable-doc \ –disable-htmlpages \ –disable-manpages \ –disable-podpages \ –disable-txtpages \ –enable-gpl \ –enable-version3 \ –disable-stripping \ –enable-muxer=flv \ –enable-protocol=file \ $ADDITIONAL_CONFIGURE_FLAGsed -i ‘’ ‘s/HAVE_LRINT 0/HAVE_LRINT 1/g’ config.hsed -i ‘’ ‘s/HAVE_LRINTF 0/HAVE_LRINTF 1/g’ config.hsed -i ‘’ ‘s/HAVE_ROUND 0/HAVE_ROUND 1/g’ config.hsed -i ‘’ ‘s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g’ config.hsed -i ‘’ ‘s/HAVE_TRUNC 0/HAVE_TRUNC 1/g’ config.hsed -i ‘’ ‘s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g’ config.hsed -i ‘’ ‘s/HAVE_CBRT 0/HAVE_CBRT 1/g’ config.hsed -i ‘’ ‘s/HAVE_RINT 0/HAVE_RINT 1/g’ config.hmake cleanmake -j4make install$TOOLCHAIN/bin/arm-linux-androideabi-ld \-rpath-link=$PLATFORM/usr/lib \-L$PLATFORM/usr/lib \-L$PREFIX/lib \-soname libffmpeg.so -shared -nostdlib -Bsymbolic –whole-archive –no-undefined -o \$PREFIX/libffmpeg.so \ libavcodec/libavcodec.a \ libavfilter/libavfilter.a \ libswresample/libswresample.a \ libavformat/libavformat.a \ libavutil/libavutil.a \ libswscale/libswscale.a \ -lc -lm -lz -ldl -llog –dynamic-linker=/system/bin/linker \ $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a} arm v7vfpCPU=arm7-aOPTIMIZE_CFLAGS=”-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU “PREFIX=./Androidbuild_one CPU=armvPREFIX=$(pwd)/android/$CPUADDI_CFLAGS=”-marm”build_one#arm v6 #CPU=armv6 #OPTIMIZE_CFLAGS=”-marm -march=$CPU” #PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG= #build_one #arm v7vfpv3 CPU=armv7-aOPTIMIZE_CFLAGS=”-mfloat-abi=softfp -mfpu=vfpv3-d16 -marm -march=$CPU “PREFIX=./android/$CPUADDITIONAL_CONFIGURE_FLAG=build_one#arm v7n #CPU=armv7-a #OPTIMIZE_CFLAGS=”-mfloat-abi=softfp -mfpu=neon -marm -march=$CPU -mtune=cortex-a8” #PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=–enable-neon #build_one #arm v6+vfp #CPU=armv6 #OPTIMIZE_CFLAGS=”-DCMP_HAVE_VFP -mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU” #PREFIX=./android/${CPU}_vfp #ADDITIONAL_CONFIGURE_FLAG= #build_one14. 编译: ./build```]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Launcher的启动]]></title>
    <url>%2F2017%2F07%2F25%2FActivity%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[尊重原创，禁止任何形式的转载与抄袭 本文选用API25分析 关键词 简写 ActivityManagerService AMS ActivityStackSupervisor ASS PackageManagerService PMS &lt;== 表示将进入方法内分析 DirectBoot之FallbackHomeDirectBootAPI24开始就加了DirectBoot的特性，开机到解锁前的时间，系统会进入DirectBoot模式。不过正常情况下没有开启，需要在开发选项或者使用adb开启。开启了DirectBoot之后有如下变化： 存储变化：系统会为应用提供两个不同的存储空间，一个是凭证加密空间，需要解锁后才能使用，另外一个是设备加密空间，不需要解锁，在启动后就能直接使用。 应用启动限制：只有标记了android:directBootAware=”true” 的组件才能在DirectBoot模式下启动，其他组件都无法启动。 FallbackHome由于系统应用Launcher本身并不支持DirectBoot，但是Android N前Launcher是在system_process启动时刻就立刻启动，这不符合上面提到的DirectBoot应用启动限制，所以，所以就在AndroidN及以上的系统应用Setttings中添加一个简易的Launcher应用叫FallbackHome，FallbackHome支持DirectBoot，不管是否开启了DirectBoot,AMS首先会在系统启动时刻启动FallbackHome，FallbackHome会自动判断如果不是处在DirectBoot模式下，是则会自动销毁自己，AMS会重启Home栈，真正的Launcher才启动。所以AndroidN后，开机会先启动FallbackHome，再启动真正的Launcher。 关键类 关键类 用途 ActivityManagerService 主要用于管理四大组件以及adb相关的工具 ActivityRecord AMS不会直接使用Activity，而是用ActivityRecord来记录Activity TaskRecord ActivityRecord的栈 ActivityStack TaskRecord的栈，主要有HomeStack跟AppStack，HomeStack包含Launcher跟RecentApp两个TaskRecord，AppStack包含普通Activity的TaskRecord ActivityStackSupervisor 用于管理ActivityStack ActivityStarter 将Intent转化成一个ActivityRecord并且加入到对应的ActivityStack，TaskRecord FallbackHome之启动AMS.systemReady12345678//AMS初始化的最后会执行systemReady方法public void systemReady(final Runnable goingCallback) &#123; ... //启动HomeActivity即是Launcher //这个Launcher就是简易的FallbackHome,默认用户UserId=0 startHomeActivityLocked(currentUserId, "systemReady");//&lt;== ...&#125; AMS.startHomeActivityLocked12345678910111213141516171819202122232425262728293031boolean startHomeActivityLocked(int userId, String reason) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) &#123; return false; &#125; //构建启动Launcher的Intent Intent intent = getHomeIntent(); //用PMS来查找对应intent的ActivityInfo //ActivityInfo代表着Manifest.xml中Activity的信息 //返回aInfo即是FallbackHome ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; //intent从隐式改成显式，启动必然是aInfo对应的Activity intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //查找现有的Processrecord中是否有FallbackHome的进程 //很明显，系统才刚开机，没有对应的进程，所以app==null ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //利用本方法中构建的Intent，ActiityInfo来启动HomeActivity mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);//&lt;== &#125; &#125; else &#123; Slog.wtf(TAG, "No home screen found for " + intent, new Throwable()); &#125; return true;&#125; ActivityStarter.startHomeActivityLocked12345678910111213141516171819void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) &#123; //将HomeStack中Launcher的TaskRecord移到顶端显示 //由于刚开机，HomeStack中并没有任何TaskRecord存在，所以没有任何效果这句 mSupervisor.moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); //传入参数只有intent，aInfo，其他都是null，0，false startActivityLocked(null , intent, null , null , aInfo, null , null , null , null , null , 0 , 0 , 0 , null , 0 , 0 , 0 , null , false , false , null , null , null ); //&lt;== // inResumeTopActivity是为了防止ActivityStack递归调用resumeTopActivityUncheckedLocked // 由于此次startHomeActivityLocked的调用是由系统启动时AMS的systemReady调过来的，不是从ActivityStack调过来的，所以不存在递归调用的问题 // 所以，inResumeActivity==false,不走以下流程 if (mSupervisor.inResumeTopActivity) &#123; mSupervisor.scheduleResumeTopActivities(); &#125;&#125; ActivityStarter.startActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276//传入参数只有intent，aInfo，其他都是null，0，falsefinal int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; ProcessRecord callerApp = null; //传参caller==null，不走这 if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //userId与uid是两种完全不一样的概念 //uid是linux中的uid概念，但被android用在了应用沙盒机制，也就是每个应用一般都有一个不同的uid //userId则是android自己创造的，通过uid分段来区分userId，userId=uid/100000(十万) final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; //普通的打log，没意义 if (err == ActivityManager.START_SUCCESS) &#123; Slog.i(TAG, "START u" + userId + " &#123;" + intent.toShortString(true, true, true, false) + "&#125; from uid " + callingUid + " on display " + (container == null ? (mSupervisor.mFocusedStack == null ? Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId))); &#125; // 下面这段代码主要跟startActvityForResult并且Intent带FLAG_ACTIVITY_FORWARD_RESULT相关 // 有兴趣可以自己结合FLAG_ACTIVITY_FORWARD_RESULT看 ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; // 传入参数resultTo==null，所以sourceRecord，resultRecord都为null if (resultTo != null) &#123; sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, "Will send result to " + resultTo + " " + sourceRecord); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; if (requestCode &gt;= 0) &#123; ActivityOptions.abort(options); return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT; &#125; resultRecord = sourceRecord.resultTo; if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123; resultRecord = null; &#125; resultWho = sourceRecord.resultWho; requestCode = sourceRecord.requestCode; sourceRecord.resultTo = null; if (resultRecord != null) &#123; resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode); &#125; if (sourceRecord.launchedFromUid == callingUid) &#123; callingPackage = sourceRecord.launchedFromPackage; &#125; &#125; //前面已经将intent改成显式intent，所以getComponent()！=null if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; //从前面也知道aInfo对应了FallbackHome,aInfo！=null if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; err = ActivityManager.START_CLASS_NOT_FOUND; &#125; //前面分析了sourceRecord=null，所以不走这里 if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.task.voiceSession != null) &#123; if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123; try &#123; intent.addCategory(Intent.CATEGORY_VOICE); if (!AppGlobals.getPackageManager().activitySupportsIntent( intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, "Activity being started in current voice task does not support voice: " + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Failure checking voice capabilities", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; &#125; //传入参数voiceSession==null，所以不走这里 if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; try &#123; if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(), intent, resolvedType)) &#123; Slog.w(TAG, "Activity being started in new voice task does not support: " + intent); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Failure checking voice capabilities", e); err = ActivityManager.START_NOT_VOICE_COMPATIBLE; &#125; &#125; //前面已经分析了resultRecord==null，所以resultStack==null final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; // 判断以上流程是否出错过，如果出错就发RESULT_CANCELED的Result给相应的Activity // 过程中没有出错，不走这里 if (err != START_SUCCESS) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked( -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return err; &#125; // 检查是否有启动对应Activity的权限 // 由于传入的callingUid==0，表示Root的uid（感觉用System的Uid比较合理），检查权限必然通过 boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp, resultRecord, resultStack, options); //IntentFirewall是一个Intent的防火墙，能够拦截特定的Intent //拦截列表一般在/data/system/ifw/*.xml,默认为空 //所以 abort==false abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); //mController是一个binder，IActivityController类型，一般用于monkey监视控制AMS对Activity的操作 if (mService.mController != null) &#123; try &#123; Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; catch (RemoteException e) &#123; mService.mController = null; &#125; &#125; //拦截应用，比如多用户模型下，非管理员可能不能打开短信电话 mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage); mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid, options); intent = mInterceptor.mIntent; rInfo = mInterceptor.mRInfo; aInfo = mInterceptor.mAInfo; resolvedType = mInterceptor.mResolvedType; inTask = mInterceptor.mInTask; callingPid = mInterceptor.mCallingPid; callingUid = mInterceptor.mCallingUid; options = mInterceptor.mActivityOptions; //abort==true时候给resultActivity发送RESULT_CANCELED //前面分析abort==false，不走这 if (abort) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return START_SUCCESS; &#125; //Build.PERMISSIONS_REVIEW_REQUIRED是否要检测API&lt;23的应用的动态权限，Build.PERMISSIONS_REVIEW_REQUIRED是false，所以不走这 if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; aInfo != null) &#123; if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired( aInfo.packageName, userId)) &#123; IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingUid, userId, null, null, 0, new Intent[]&#123;intent&#125;, new String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); final int flags = intent.getFlags(); Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); newIntent.setFlags(flags | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName); newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target)); if (resultRecord != null) &#123; newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true); &#125; intent = newIntent; resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); if (DEBUG_PERMISSIONS_REVIEW) &#123; Slog.i(TAG, "START u" + userId + " &#123;" + intent.toShortString(true, true, true, false) + "&#125; from uid " + callingUid + " on display " + (container == null ? (mSupervisor.mFocusedStack == null ? Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId))); &#125; &#125; &#125; //传参rInfo==false,不走这 if (rInfo != null &amp;&amp; rInfo.ephemeralResolveInfo != null) &#123; intent = buildEphemeralInstallerIntent(intent, ephemeralIntent, rInfo.ephemeralResolveInfo.getPackageName(), callingPackage, resolvedType, userId); resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); &#125; //构建ActivityRecored ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); if (outActivity != null) &#123; outActivity[0] = r; &#125; //前面分析了sourceRecord==null，不走这 if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; r.appTimeTracker = sourceRecord.appTimeTracker; &#125; //mSupervisor.mFocusedStack在AMS设置WindowManager就设置成HomeStack final ActivityStack stack = mSupervisor.mFocusedStack; //这块主要处理AppSwitch，当按下home键后，会回到home界面。 //从按下Home键之后5秒内，后台启动Activity（非用户主动）会进入队列中等待启动，5秒结束了才会启动 if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, "Activity start")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack, callerApp); mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; doPendingActivityLaunchesLocked(false); try &#123; mService.mWindowManager.deferSurfaceLayout(); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask);//&lt;== &#125; finally &#123; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack); return err;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Android</tag>
        <tag>AM</tag>
      </tags>
  </entry>
</search>